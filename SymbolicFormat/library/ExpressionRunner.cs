//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace SymbolicCalculator {
	using System;
	using System.Reflection;
	using System.CodeDom;
	using System.CodeDom.Compiler;
	using Microsoft.CSharp;
	using System.Text;
	using System.Windows.Forms;
	
	
	/// <summary>
	/// Compiles and runs an expression output from the parser.
	/// </summary>
	/// <remarks>
	/// 	created by - Adam Berger
	/// 	created on - 10/6/2003 4:01:12 PM
	/// </remarks>
	public class ExpressionRunner : object {
		string expression;
		Assembly assembly;
		
		public ExpressionRunner( string exp ) {
			expression = exp;
		}
		
		public string Run( ) {
			// compile expression
			assembly = Compile( expression );
			
			// run expression
			object exp = assembly.CreateInstance( "RuntimeSymbolicCalculator.Expression" );
			MethodInfo mi = exp.GetType( ).GetMethod( "Evaluate" );
      		object ret = mi.Invoke( exp, null );
			
			return (string)ret;
		}
		
		private Assembly Compile( string expression ) {
			System.Resources.ResourceManager rMan = new
				System.Resources.ResourceManager("Resources", GetType().Assembly);

			ICodeCompiler comp = ( new CSharpCodeProvider( ).CreateCompiler( ) );
			CompilerParameters cp = new CompilerParameters( );
			cp.ReferencedAssemblies.Add( "system.dll" );
			cp.ReferencedAssemblies.Add( @"SymbolicFunctionLibrary.dll" );
			cp.GenerateExecutable = false;
			cp.GenerateInMemory = true;
			
			StringBuilder code = new StringBuilder( );
			code.Append( "using System; \n" );
			code.Append( "using SymbolicFunctionLibrary; \n" );
			code.Append( "namespace RuntimeSymbolicCalculator { \n" );
			code.Append( "  public class Expression { \n" );
			code.Append( "		public string Evaluate( ) {\n" );
			code.Append( "		return " );
			code.Append( 			expression );
			code.Append( "			.ToString( );" );
			code.Append( "} } }" );
			
			CompilerResults cr = comp.CompileAssemblyFromSource( cp, code.ToString( ) );
			if ( cr.Errors.HasErrors ) {
				StringBuilder error = new StringBuilder( );
				error.Append( "Error Compiling Expression: " );
				foreach ( CompilerError err in cr.Errors )
				{
					error.AppendFormat( "{0}\n", err.ErrorText );
				}
				throw new Exception( error.ToString( ) );
			}
			return cr.CompiledAssembly;
		}
	}
}
