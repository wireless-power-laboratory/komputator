//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace SymbolicCalculator {
	using System;
	using System.Collections;
	using SymbolicFunctionLibrary;
	
	
	/// <summary>
	/// Parses a mathematical expression such as "a+b" into the form "Plus[a,b]"
	/// </summary>
	/// <remarks>
	/// 	created by - Adam Berger
	/// 	created on - 10/5/2003 2:51:47 PM
	/// </remarks>
	public class Parser : object {
		
		public Parser( ) {
		}
		
		// translates a human-readable expression into a hierarchy
		// of nodes
		public INode Parse( string source, ArrayList functions ) {
			SortedList indeciesOfNodes = new SortedList( );
			
			// first get indexes of Open Parenthesis
			OpenParenthesis open = new OpenParenthesis( );
			ArrayList openParens = open.GetStartingIndexes( source );
			foreach ( int index in openParens ) {
				indeciesOfNodes.Add( index, open );
			}
			
			// then get indexes of Close Parenthesis
			CloseParenthesis close = new CloseParenthesis( );
			ArrayList closeParens = close.GetStartingIndexes( source );
			foreach ( int index in closeParens ) {
				indeciesOfNodes.Add( index, close );
			}
			
			// then get indexes of Reals
			Real real = new Real( );
			ArrayList reals = real.GetStartingIndexes( source );
			foreach ( int index in reals ) {
				indeciesOfNodes.Add( index, real );
			}
			
			// now indexes of Functions
			SortedList funcs = new SortedList( );
			int highestOrderOfOpsLevel = 0;
			foreach ( FunctionDescription funcDesc in functions ) {
				// make a dictionary of IFunctions and the 
				// starting index of that function
				foreach ( int index in funcDesc.FunctionClass.GetStartingIndexes( source ) ) {
					Type funcType = funcDesc.FunctionClass.GetType( );
					System.Reflection.Assembly a = funcType.Assembly;
					object funcInstance = a.CreateInstance( funcType.FullName );
					funcs.Add( index,
					          funcInstance
					          );
					indeciesOfNodes.Add( index,
					          funcInstance
					          );
					
					if ( funcDesc.OrderOfOperationsLevel > highestOrderOfOpsLevel )
						highestOrderOfOpsLevel = funcDesc.OrderOfOperationsLevel;
				}
			}
			
			// now make nodes for each element
			ArrayList nodes = new ArrayList( );
						
			foreach ( DictionaryEntry entry in indeciesOfNodes ) {
				switch ( ((INode)entry.Value).Type ) {
					case NodeType.OpenParenthesis:
						OpenParenthesis openNode = new OpenParenthesis( );
						openNode.StartingIndex = nodes.Add( openNode );
						break;
					case NodeType.CloseParenthesis:
						CloseParenthesis closeNode = new CloseParenthesis( );
						closeNode.StartingIndex = nodes.Add( closeNode );
						break;
					case NodeType.Real:
						Real realNode = new Real( );
						realNode.GetValue( (int)entry.Key, source );
						nodes.Add( realNode );
						break;
					case NodeType.Function:
						int index = nodes.Add( entry.Value );
						((IFunction)nodes[nodes.Count-1]).Index = index;
						break;
				}
			}
			
			// change (...)(...) into (...)*(...)
			ParseImplicitMultiplication( ref nodes );
			
			// get (...) contents
			for ( int i=0; i<openParens.Count; i++ ) {
				ParenthesisBlock pBlock = 
					new ParenthesisBlock( ref nodes );
			}
			
			// loop through and let each function get its parameters
			/*for ( int i=0; i<=highestOrderOfOpsLevel; i++ ) {
				int nodeIndex = 0;
				for ( int j=0; j<funcs.Count; j++ ) {
					IFunction func = (IFunction)funcs.GetByIndex( j );
					if ( func.OrderOfOperationsLevel == i ) {
						int nodesRemoved = func.ResolveParameters( nodes );
						// change the indecies of the other functions after the
						// one removed
						foreach ( DictionaryEntry e in funcs ) {
							IFunction f = (IFunction)e.Value;
							if ( f.Index > func.Index )
								f.Index -= nodesRemoved;
						}
					}
					
					nodeIndex++;
				}
			}*/
			
			// All that's left in nodes is the topmost Node,
			// because that isn't a parameter for anything else
			return (INode)nodes[0];
		}
		
		// replace implied multiplication with '*'
		private void ParseImplicitMultiplication( ref ArrayList nodes ) {
			for ( int i=0; i<(nodes.Count-1); i++ ) {
				if ( ((INode)nodes[i]).Type == NodeType.CloseParenthesis &&
					 ((INode)nodes[i+1]).Type == NodeType.OpenParenthesis ) {
					
					// make a new Times function node
					Type timesType = typeof( Parser ); // have to init to something
					foreach ( FunctionDescription f in Functions.GetFunctions( ) ) {
						if ( f.Name == "Times" )
							timesType = (Type)f.FunctionClass.GetType( );
					}
					
					System.Reflection.Assembly a = timesType.Assembly;
					object timesFuncInstance = a.CreateInstance( timesType.FullName );					
					 	
					// insert our new function between )(
					nodes.Insert( i+1, timesFuncInstance );
					
					// correct the indecies of parens and funcs after the insertion
					foreach ( INode n in nodes ) {
						if ( n.Type == NodeType.Function ) {
							IFunction func = (IFunction)n;
							if ( func.Index > i )
								func.Index++;
						}
						if ( n.Type == NodeType.OpenParenthesis ) {
							OpenParenthesis op = (OpenParenthesis)n;
							if ( op.StartingIndex > i )
								op.StartingIndex++;
						}
						if ( n.Type == NodeType.CloseParenthesis ) {
							CloseParenthesis cp = (CloseParenthesis)n;
							if ( cp.StartingIndex > i )
								cp.StartingIndex++;
						}
					}
					 	
				}
			}
		}
				
		// returns an ArrayList with the indexes of the specified char
		private static ArrayList GetAllIndexesOf( string source, string val ) {
			ArrayList Indexes = new ArrayList( );
			int test = source.IndexOf( val, 0 );
			
			if ( test != -1 ) {
				Indexes.Insert( 0, test );
				int i=1;
				do  {
					Indexes.Insert( i,
						source.IndexOf( val, (int)Indexes[i-1]+1 )
						);
					i++;
				} while ( ((int)Indexes[i-1]) != -1 );
				Indexes.Remove( (-1) );
			}
			
			return Indexes;
		}
	}
	
	public class DescendingIntComparer : IComparer {
		public DescendingIntComparer( ){
			
		}
#region System.Collections.IComparer interface implementation
		public int Compare(object x, object y)
		{
			int rhs = (int) x;
			int lhs = (int) y;
			
			int retVal = rhs.CompareTo( lhs );
			if ( retVal != 0 )
				return ( -retVal ); // descending
			else
				return 0;
		}
#endregion

	}
	
	public class AscendingIntComparer : IComparer {
		public AscendingIntComparer( ){
			
		}
#region System.Collections.IComparer interface implementation
		public int Compare(object x, object y)
		{
			int rhs = (int) x;
			int lhs = (int) y;
			
			return rhs.CompareTo( lhs );
		}
#endregion

	}
}
